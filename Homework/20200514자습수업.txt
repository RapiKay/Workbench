#include <stdio.h>

main()
{
	char a = A;
	printf("%d", a);
}

출력 결과 : 65.

왜 char형의 a에 A라는 값을 넣었는데 65가 출력됐는가?

%d 는 int형을 출력하지만, a는 char형이다. 따라서 char형의 a를 int형으로 바뀌어야 출력이 될 수 있다.
여기서는 아스키코드가 사용되는데, 대표적으로 대문자 A 가 65의 아스키코드 값을 갖는다.
따라서 char 형의 a에 들어있는 A는 아스키코드가 사용되어 int형으로 바뀔 때 65라는 값을 가진다.

#include <stdio.h>

main()
{
	int i, j;
	for(i = 1; i <= 9; i++){
		for(j = 0; j <= 8; j++){
			printf("%d이(가) %d번 출력됨.\n", j, i);
		}
	}
}

에서 제일 먼저 출력 되는 문과 제일 마지막에 출력되는 문은 무엇인가?

제일 먼저 출력 : 0이(가) 1번 출력됨.

제일 마지막에 출력 : 8이(가) 9번 출력됨.

0을 출력하지 않게 하려면?

7행에 for문에서 j = 0 을 j = 1로 고친다.

만약 i가 사용되고 있는 for문을 while문으로 고쳐 작성하려고 했으나, 위의 소스파일과 같은 결과가 나오지 않았다. 다음 소스파일을 보고
문제에 답하여라. ( 홍콩반점 )

#include <stdio.h>

main()
{
    int i = 9, j;

    while(i >= 1){
        for(j = 0; j <= 8; j++){
			printf("%d이(가) %d번 출력됨.\n", j,i);
		}
		i--;
    }
}

제일 먼저 출력되는 문과 마지막에 출력되는 문

제일 먼저 출력되는 문 : 0이(가) 9번 출력됨

마지막에 출력되는 문 : 8이(가) 1번 출력됨

for문을 사용한 소스파일과 while문을 사용한 소스파일의 결과가 다른 이유를 서술하시오.

for문에서는 i의 값을 0에서 시작하여 9까지 늘리며 출력했지만, while문에서는 i의 값을 9에서 시작하여 1까지 줄였기 때문에 for문을 사용한
소스파일과 while문을 사용한 소스파일의 결과가 다르게 출력된다.

while문을 사용한 소스파일의 출력문을 for문과 같게 하려면 어떻게 해야 할까?

#include <stdio.h>

main()
{
	int i = 1, j;

    while(i <= 9){
        for(j = 0; j <= 8; j++){
			printf("%d이(가) %d번 출력됨.\n", j,i);
		}
		i++;
    }
}


for문과 똑같이 1에서 9까지 늘리는 방법을 사용한다.

홀수, 짝수 판별을 위한 소스 제작 중 문제가 발생했다. 다음에 답하시오 ( 고기 한 점 )
#include <stdio.h>

main()
{
	int num;
	
	printf("숫자를 입력하시면 홀수인지 짝수인지 판별합니다.\n");
	printf("숫자를 입력해주세요: ");
	scanf("%d", &num);
	
	if((num % 2) == 0)
	{
		printf("입력하신 숫자 %d는 홀수입니다. \n", num);
	}
	printf("입력하신 숫자 %d는 짝수입니다. \n", num);
	return 0; 
}

홀수가 아닌 짝수일 때 입력하신 숫자 ( )는 홀수입니다. 가 출력된다. 이 버그를 수정하시오

if(num % 2) == 0) 을 if(num % 2) == 1) 으로 수정한다.

홀수임에도 입력하신 숫자 ( )는 짝수입니다. 가 출력된다. 이 버그를 수정하시오.

printf("입력하신 숫자 %d는 홀수입니다. \n", num); 뒤에 return 0;을 써 넣는다.

10을 2진수로 바꾸시오

1010

10의 2진수를 그레이코드로 바꾸시오

1111
